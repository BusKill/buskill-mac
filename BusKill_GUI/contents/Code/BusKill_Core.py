import os
import fnmatch
import sys
import subprocess
import BusKill_GUIElements
from PyQt5.QtCore import QThread

class Controller:

    def __init__(self):
        self.APPPATH = "../"

    def _getAPPPATH(self):
        location = sys.argv[0]
        location = location.split("/")
        location_length = len(location)
        del location[location_length-1]
        del location[location_length-2]
        print(location)
        return "/".join(location)

    def _getTriggers(self):
        self.Triggers = []
        self.dirlist = os.listdir(os.path.join(self.APPPATH, "Triggers/"))
        for dir in self.dirlist:
            if os.path.isdir(os.path.join(self.APPPATH, "Triggers/", dir)) == True:
                self.Triggers.append(dir)
        return self.Triggers

    def _getDevices(self):
        self.Devices = os.listdir("/dev")
        self.Disk_Devices = ["DUMMY DATA"]
        for Device in self.Devices:
            if fnmatch.fnmatch(Device, "*disk*"):
                if Device.startswith("r") == False:
                    if fnmatch.fnmatch(Device, "*isk*s*") == False:
                        if Device.endswith("1") == False:
                            if Device.endswith("0") == False:
                                self.Disk_Devices.append(Device)
        return self.Disk_Devices

    def _getConfig(self):
        self.Config = []
        self.dirlist = os.listdir(os.path.join(self.APPPATH, "Config/"))

        #shit tonne of if statements

        return self.Config

    def _executeTrigger(self, Trigger):
        subprocess.call("python Trigger.py", shell = True)

    def _checkDevice(self, Device):
        if os.path.exists("/dev/"+Device) == True:
            return True
        else:
            return False
            #add WriteLog in here

    def _validation(self, Trigger ,Device):
        Trig = True
        Dev = True
        #add some actual validation in here.
        #add some specific self._errorHandling() Messages Depending on what has failed Validation
        return Trig and Dev

    #unsupported
    def _createConfig(self):
        function = None
    #unsupported
    def _exportLog(self):
        function = None
    #unsupported
    def _selectLogSaveLocation(self):
        function = None
    #unsupported
    def _selectTriggerInstaller(self):
        function = None
    #unsupported
    def _writeLog(self, Severity, Message):
        function = None

    def _errorHandling(self, Severity, Message):
        if Severity.lower() == "critical":
            window = BusKill_GUIElements.BusKill_CritMessage(Message)
        elif severity.lower() == "informative":
            window = BusKill_GUIElements.BusKill_InfoMessage(Message)

        self._writeLog(Severity, Message)

class Runtime(QThread):

    def __init__(self, Trigger, Device):
        QThread.__init__(self)
        self.APP_CTRL = Controller()
        self.Trigger = Trigger
        self.Device = Device

    def __del__(self):
        self.wait()

    def run(self):
        os.chdir("../Triggers/"+self.Trigger+"/")
        Triggered = False
        while Triggered == False:
            if self.APP_CTRL._checkDevice(self.Device) == False:
                self.APP_CTRL._executeTrigger(self.Trigger)
                Triggered = True
                return

class Configuration:

    def __init__(self):
        pass

    def _createConfig(self, name, Device, Trigger):
        if os.file.exists(os.path.join("Config/",name,".BSConf")) == False:
            with open("Config/"+name+".BSConf","a") as NewConfig:
                NewConfig.write("THIS FILE CAN BE MODIFIED MANUALLY. IF IT FAILS VALIDATION PLEASE CLEAR CONFIGURATION \n")
                NewConfig.write("Trigger:"+Trigger+"\n")
                NewConfig.write("Device:"+Device+"\n")
                NewConfig.write("this file was generated by buskill")
        else:
            function = None
            #return an error pop up, go back to main

    def _getConf(self, name):
        self.values = []
        try:
            with open("Config/"+name+".BSConf") as Conf:
                self.values.append(conf.readlines()[1].split(":")[1]) #Trigger
                self.values.append(conf.readline()[2].split(":")[1]) #Device
                return self.values
        except IOERROR:
            function = None
            #return an error pop up and go back to main
